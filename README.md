Временная сложность данного кода: O(max_iter) или O(k), где k = max_iter. В основном цикле каждая итерация имеет постоянное время O(1). 
Внутри цикла: компьютер как бы шевелит текущее решение, добавляя небольшое случайное смещение, random.uniform(-1, 1) - просим дать случайное число от -1 до 1, умножаем на temperature - чем "горячее" система, тем больше шаг. Дальше происходит оценка качества нового решения, то есть: мы вызываем "функцию энергии" - это наш как бы строгий экзаменатор. Он проверяет: насколько новое решение (x, y) близко к правильному ответу, считает "штрафные баллы": чем дальше от истины, тем больше энергия. Далее мы сравниваем старое и новое решение: вычисляем разницу:новая_энергия - старая_энергия, если delta_energy < 0 - новое решение лучше, если же delta_energy > 0 - новое решение хуже. И в итоге мы принимем решение, точнее вычисляем вероятность принятия худшего решения.
Хотя температура уменьшается по экспоненте, количество итераций ограничено max_iter, поэтому сложность линейна относительно этого параметра. Количество итераций = min(⌈log(min_temp/initial_temp) / log(cooling_rate)⌉,
max_iter). Но поскольку мы используем max_iter как жесткое ограничение, фактическое количество итераций = min(бесконечность, max_iter) = max_iter. 
Уточненная сложность: 
Худший случай: O(max_iter) - достигается при max_iter итерациях
Средний случай: O(max_iter) - так как обычно достигается max_iter
Лучший случай: O(1) - если нашли идеальное решение сразу, однако аглоритм продолжает работу
Приводя итоги, можно сказать, что алгоритм имеет линейную сложность O(max_iter) относительно количества итераций, но поскольку max_iter - фиксированный параметр, на практике это константная сложность для конкретного запуска. 
Контрольные вопросы:
1. Приближенный алгоритм — это алгоритм, который находит не обязательно оптимальное, но близкое к оптимальному решение за полиномиальное время. Основная цель для NP-сложных задач: поскольку для многих NP-сложных задач не известно полиномиальных алгоритмов, нахождение точного решения требует экспоненциального времени. Приближенные алгоритмы позволяют найти "достаточно хорошее" решение за разумное время.
2. Коэффициент аппроксимации α >= 1 - минимальное число такое, что для всех входов I: ALG(I) <= α * OPT(I), где ALG(I) - стоимость решения, найденного алгоритмом на входе I, OPT(I) - стоимость оптимального решения. Этот коэффициент характеризует насколько "плохим" может быть решение алгоритма по сравнению с оптимальным в худшем случае.
3. 1) PTAS: для любого эпсилон большего нуля существует алгоритм с коэффициентом аппроксимации 1 + эпсилон, время работы полиномиально относительно размера входа n, но может быть экспоненциально относительно 1 / эпсилон. Пример: O(n^1/эпсилон) 2) FPTAS: Время работы полиномиально относительно и n, и 1/эпсилон. Пример: O(n^2/эпсилон). FPTAS имеет более строгие требования к времени работы.
4. Алгоритм выбирает рёбра без общих вершин (паросочетание)
